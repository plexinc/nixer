import os
import platform
import sys
import tarfile
from glob import iglob
from pathlib import Path
from typing import Tuple

from devstory import output
from devstory.artifactory import Artifactory
from devstory.common import (
  CommandResult,
  DsConfig,
  current_context,
  ds_halo,
  get_git_branch_name,
  get_info_file,
  get_info_file_path,
  get_project_dir,
  is_truthy,
  is_windows,
  run_command,
)
from devstory.common.common import using_new_toolchain

PROFILES_REPO = "plexinc/plex-build-profiles"
CONFIG_FILE = ".plex_dev"

_artifactory = Artifactory.default()


def get_ref():
  output.trace("Selecting ref...")
  if "PLEX_BUILD_PROFILES_REF" in os.environ:
    output.trace("Using PLEX_BUILD_PROFILES_REF " "environment variable")
    return os.environ["PLEX_BUILD_PROFILES_REF"]
  config_path = get_project_dir() / CONFIG_FILE
  if config_path.exists():
    output.trace("Using .plex_dev file")
    conf = DsConfig(str(config_path))
    return conf.load_setting("bootstrap", "ref")
  # due to artifactory caching weirdness,
  # we can't simply return "master" as the final
  # fallback.
  output.trace("Using current master as fallback")
  master_ref = _artifactory.get_ref_sha(PROFILES_REPO, "master")
  output.trace(master_ref)
  return master_ref


def get_remote():
  conf = DsConfig.load_plex_dev()
  remote = conf.load_setting("bootstrap", "remote")
  return remote


def get_toolchain():
  conf = DsConfig.load_plex_dev()
  toolchain = conf.load_setting("bootstrap", "install_toolchain", True)
  return is_truthy(toolchain)


def get_user_channel():
  conf = DsConfig.load_plex_dev()
  user_channel = conf.load_setting("bootstrap", "user_channel")
  if user_channel and "/" not in user_channel:
    output.warn("Malformatted channel in .plex_dev, expected user/channel")
    return None
  return user_channel


def download_build_profiles(output_name, ref):
  output.info("Downloading profiles")
  with ds_halo():
    resp, sha = _artifactory.download_ref(PROFILES_REPO, ref)
    with open(output_name, "wb") as file_data:
      file_data.write(resp)
    return sha


def extract(file_name, dirname, ref):
  output.info("Extracting...")
  with tarfile.open(file_name) as file_data:
    file_data.extractall(".")
  # small trick with iglob follows: if a short commit hash is given as ref,
  # the extracted directory name will not match exactly. iglob will find the
  # partial match.
  extracted = next(iglob("plex-build-profiles-{}*".format(ref.replace("/", "-"))))
  os.rename(extracted, dirname)
  os.remove(file_name)


def run_init(build_dir, remote, toolchain, user_channel):
  ctx = current_context()
  output.info(
    "Running conan_init. This may take a minute or two.", style=output.SUCCESS_STYLE
  )
  if not build_dir.exists():
    output.info("Build directory does not exist, creating...")
    build_dir.mkdir()
  current_dir = os.getcwd()
  os.chdir(build_dir)

  # Before we run conan_init we should remove some older files
  # generated by conan install
  files_to_remove = (
    "conaninfo.txt",
    "conanbuildinfo.cmake",
    "initial-cache.cmake",
    "plex-toolchain.cmake",
    "shared-libs-release.cmake",
    "",
  )
  for fpath in files_to_remove:
    if os.path.exists(fpath):
      output.info(f"Removing {fpath} ...")
      os.remove(fpath)

  toolchain_arg = ["--no-install-toolchain"] if not toolchain else []

  extra_env = os.environ.copy()
  extra_env["PLEX_PYPI_REPO"] = "pypi-tools-and-cache"
  extra_env["CONAN_USERNAME"], extra_env["CONAN_CHANNEL"] = user_channel.split("/")
  if platform.system() != "Windows":
    extra_env["CCACHE_SLOPPINESS"] = "pch_defines,time_macros"

  try:
    result = run_command(
      [
        sys.executable,
        str(ctx.home / "profiles" / "conan_init.py"),
        "-vr",
        remote,
        "--skip-hook",
      ]
      + toolchain_arg,
      env=extra_env,
    )
    if result != 0:
      output.error("conan_init returned " + str(result))
      return CommandResult.Error
  finally:
    os.chdir(current_dir)
  return CommandResult.Success


def save_bootstrap_config(saved_info, requested_ref, remote, toolchain, params):
  output.info("Saving bootstrap configuration to " + get_info_file_path())
  profiles = Path("profiles")
  if not profiles.is_dir():
    raise RuntimeError("profiles directory does not exist!")
  sha = _artifactory.get_ref_sha(PROFILES_REPO, requested_ref)

  if saved_info:
    output.info("Restoring earlier .ds_info file")
    with open(get_info_file_path(), "w") as info_file:
      info_file.write(saved_info)

  info_file = get_info_file()
  info_file.save_setting("devstory", "ref", requested_ref)
  info_file.save_setting("devstory", "sha", sha)
  info_file.save_setting("devstory", "remote", remote)
  info_file.save_setting("devstory", "install_toolchain", str(toolchain))

  import json

  info_file.save_setting("configuration", "bootstrap", json.dumps(params))


def _backup_info_file():
  info_file_path = get_info_file_path() or "profiles/.ds_info"
  if Path(info_file_path).exists():
    output.info("Found earlier .ds_info file, saving its contents.")
    with open(info_file_path) as info_file:
      return info_file.read()
  return None


def get_vcvars_cmds() -> Tuple[str, str]:
  """
  :returns: Two commands, the first one is for x86 targets, the second one for x86_64.
  """
  from subprocess import PIPE, run

  vswhere = run(
    [
      "profiles/vswhere.exe",
      "-version",
      "16.0",
      "-products",
      "*",
      "-requires",
      "Microsoft.VisualStudio.Component.VC.Tools.x86.x64",
      "-property",
      "installationPath",
    ],
    stdout=PIPE,
  )
  msvc_path = vswhere.stdout.decode().strip()
  vcvarsall = f"{msvc_path}\\VC\\Auxiliary\\Build\\vcvarsall.bat"
  return f'"{vcvarsall}" amd64_x86', f'"{vcvarsall}" amd64'


def are_vcvars_ok() -> bool:
  if not is_windows():
    return True
  plex_dev = DsConfig.load_plex_dev()
  required = is_truthy(plex_dev.load_setting("project", "vcvars_required", False))
  if not required:
    return True
  from shutil import which

  if which("cl") is None:
    output.error("Can't file cl.exe on path.")
    x86_vcvars, x86_64_vcvars = get_vcvars_cmds()
    output.error(
      "Try the following commands before running bootstrap (note the quotes and the parameter):"
    )
    print(f"\n    For 32-bit builds: {x86_vcvars}")
    print(f"    For 64-bit builds: {x86_64_vcvars}\n")
    print("If you are unsure, choose 32-bit.")
    return False
  return True


def bootstrap_new_toolchain():
  output.warn(
    "This project is using the new style toolchain - which doesn't require the bootstrap step."
  )
  output.warn(
    "boostrap now only checks if you have grabdeps and tries to update the toolchain"
  )
  try:
    run_command(["pconan", "--install-toolchain"])
  except FileNotFoundError:
    output.error("Missing grabdeps! Try to install pip install -U grabdeps")
    return CommandResult.Error
  except Exception as e:
    raise e
  return CommandResult.Success


def do_bootstrap(
  init, build_dir, remote, ref, no_toolchain, user_channel, user_channel_from_branch
):
  if using_new_toolchain():
    return bootstrap_new_toolchain()

  params = locals()
  ctx = current_context()
  ref = ref or get_ref()
  tgz = "build-profiles-{}.tgz".format(ref.replace("/", "-"))
  dirname = "profiles"

  # get the remote from .plex_dev if we don't have it passed
  remote = remote or get_remote() or "experimental"

  # if you pass --no-toolchain we will never install the toolchain
  toolchain = not no_toolchain

  # if you have configured toolchain=False in the .plex_dev file
  # we will honour that if you don't pass it on the command line
  if toolchain and not get_toolchain():
    toolchain = False

  # we read user/channel from .plex_dev - allow user_channel or
  # user_channel_from_branch to override
  user_channel = user_channel or get_user_channel() or "plex/stable"

  # if this option is set we try to use the branch name as our
  # user/channel pair.
  if user_channel_from_branch:
    branch = get_git_branch_name()
    if branch:
      if "/" in branch:
        user_channel = branch
      else:
        user_channel = f"plex/{branch}"

  if "/" not in user_channel:
    output.warn("Malformatted channel, expected user/channel")

  output.info(f"Using conan {user_channel}, remote: {remote}")

  saved_info = _backup_info_file()
  try:
    if os.path.exists(dirname):
      from shutil import rmtree

      rmtree(dirname)
    sha = download_build_profiles(tgz, ref)
    extract(tgz, dirname, sha)
    if init:
      if not are_vcvars_ok():
        return CommandResult.Error
      run_init(ctx.home / build_dir, remote, toolchain, user_channel)
    save_bootstrap_config(saved_info, ref, remote, toolchain, params)
  # pylint: disable=W0702
  except:
    import traceback

    traceback.print_exc()
    return CommandResult.Error
  return CommandResult.Success
