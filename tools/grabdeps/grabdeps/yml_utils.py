from argparse import Namespace
import json
from pathlib import Path
from collections import defaultdict
from typing import Iterable, List, Dict


def get_tarball_name(entry: dict, context: dict) -> str:
  scheme = entry.get("scheme", "{config}")
  return scheme.format_map(context)


def get_sha(entry: dict) -> str:
  return entry["sha"].strip()


def get_deps_buildinfo_path(product: str, entry: dict, context: dict) -> Path:
  dir_name = get_tarball_name(entry, context)
  return Path(product) / dir_name / "plex-buildinfo.cmake"


def write_superbuildinfo(file_path: Path, potential_paths: Iterable[Path]):
  with file_path.open("w") as fp:
    fp.write("### This file was generated by gd2.\n")
    for path in potential_paths:
      real_path = file_path.parent / path
      # `path.parent.parent` is used to get a config-independent name, i.e `pms-nano` instead of
      # `pms-nano/nano-x86_64-darwin-something-something`
      dep_dir_name = f"PLEX_DEPS_{str(path.parent.parent.name).upper()}_ROOT"
      dep_dir_name = dep_dir_name.replace("-", "_")
      dep_dir_path = str(path.parent).replace("\\", "/")
      fp.write(f"set({dep_dir_name} ${{CMAKE_CURRENT_LIST_DIR}}/{dep_dir_path})\n")
    fp.write("\n")
    for path in potential_paths:
      real_path = file_path.parent / path
      if real_path.exists():
        path_str = str(path).replace("\\", "/")
        fp.write(f"include(${{CMAKE_CURRENT_LIST_DIR}}/{path_str})\n")
    fp.write("\n")


def write_superbuildinfo_json(
  file_path: Path, potential_paths: Iterable[Path], commandline_args: Namespace
):
  data = {}
  paths = {}
  for path in potential_paths:
    # `path.parent.parent` is used to get a config-independent name, i.e `pms-nano` instead of
    # `pms-nano/nano-x86_64-darwin-something-something`
    dep_dir_name = str(path.parent.parent.name)
    dep_dir_path = str(path.parent).replace("\\", "/")
    paths[dep_dir_name] = dep_dir_path
  data["dirs"] = paths
  data["args"] = vars(commandline_args)
  if "output_dir" in data["args"]:
    data["args"]["output_dir"] = str(data["args"]["output_dir"])
  with file_path.open("w") as fp:
    json.dump(data, fp, indent=2)


def write_super_sharedlib_list(file_path: Path):
  # dict to detect identical files.
  # This containing sets warrants an explanation: even though we are not deduplicating the list
  # between different sources of the same files (e.g. you add two tarballs that both contain ffmpeg)
  # we DO deduplicate for completely identical paths (e.g. when a path exists twice in the metadata,
  # which does happen sometimes).
  filenames = defaultdict(set)
  for meta in file_path.parent.rglob("metadata.json"):
    files = (meta.parent / fname for fname in json.load(meta.open())["shared_libs"])
    for fpath in files:
      filenames[fpath.name].add(fpath)

  # To detect duplicates we check the length of all sets. If there is at least one with
  # more than one item, that means there is a dupe.
  if not all(len(lst) == 1 for lst in filenames.values()):
    print("WARNING: there are identically named shared libraries in the dependencies.")
    print(
      "If you are copying these files to the same location, some of them will be overwritten."
    )
    print("Otherwise, this is can be safely ignored.")

  # merge all sets into a single list
  filenames = list(set().union(*filenames.values()))
  with file_path.open("w") as fp:
    fp.write("### This file was generated by gd2.\n")
    fp.write("set(GRABDEPS_SHARED_LIBS\n")
    for fname in filenames:
      relname = str(fname.relative_to(file_path.parent)).replace("\\", "/")
      fp.write(f"  ${{CMAKE_CURRENT_LIST_DIR}}/{relname}\n")
    fp.write(")\n")


CfgSpecDict = Dict[str, List[str]]

# The config spec might be:
#   - a list of dep:config entries
#   - a list of *:config entries
#   - a list of configs
#   - a mix of the above
# When a list of configs is provided, that will be interpreted as *:config for
# uniformity.
def parse_config_spec(cfg_args: List[str]) -> CfgSpecDict:
  result = defaultdict(list)
  for arg in cfg_args:
    if ":" not in arg:
      result["*"].append(arg)
      continue
    try:
      dep, cfg = arg.split(":")
      result[dep].append(cfg)
    except ValueError:
      raise RuntimeError(
        f"Could not parse config {arg}. Must be `dep:config` or `config`."
      )
  return dict(result)


def get_configs_for_dep(dep_name: str, cfg_specs: CfgSpecDict) -> List[str]:
  if dep_name in cfg_specs:
    return cfg_specs[dep_name]
  elif "*" in cfg_specs:
    return cfg_specs["*"]
  else:
    return []


def remap_configs(entry: dict, configs: List[str]) -> List[str]:
  if "config-map" not in entry:
    return configs

  new_configs = []
  cm = entry["config-map"]
  for cfg in configs:
    if cfg in cm:
      new_configs.append(cm[cfg])
    else:
      new_configs.append(cfg)

  return new_configs


def filter_configs(entry: dict, configs: List[str], variant: str) -> List[str]:
  if "config-exclude" not in entry:
    return configs

  new_configs = []
  for cfg in configs:
    filter = False
    for excl in entry["config-exclude"]:
      if excl == f"{variant}/{cfg}" or excl == cfg:
        filter = True

    if not filter:
      new_configs.append(cfg)

  return new_configs
